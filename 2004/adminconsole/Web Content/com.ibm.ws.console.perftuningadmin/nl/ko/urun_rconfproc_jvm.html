<!--DITA to HTML transform for WAS-->
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JVM(Java Virtual Machine) 설정</title>
<link rel="stylesheet" href="was_style_help.css">

</head>
<body>
<a name="urun_rconfproc_jvm"></a>
<h2>JVM(Java Virtual Machine) 설정</h2>

<p>이 페이지를 참조하여 Application Server의 프로세스에 대한 JVM 구성을 보고 변경하십시오.
</p>

<p>이 관리 콘솔 페이지를 보려면 <strong>서버 &gt; Application Servers &gt; </strong><em>server_name</em><strong> &gt; 프로세스 정의 &gt; JVM(Java Virtual Machine)</strong>을 클릭하십시오. </p>

<div>
<p>
<strong>구성 탭</strong>
</p>
<dl>
<dt>
<strong><a name="JavaVirtualMachine_classpath_description"></a>클래스 경로</strong>
</dt>
<dd>Java 가상 시스템 코드가 클래스를 찾는 표준 클래스 경로를 지정합니다.

<p>각 클래스 항목을 테이블 행에 입력하십시오. 각 항목의 끝에 콜론이나 세미콜론을 추가할 필요는 없습니다.</p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">
단위</td>
<td align="left" valign="top" class="base">클래스 경로</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_bootClasspath_description"></a>부트 클래스 경로</strong>
</dt>
<dd>JVM 코드에 대한 부트스트랩 클래스 및 자원을 지정합니다. 이 옵션은 부트스트랩
클래스 및 자원을 지원하는 JVM에 대해서만 사용 가능합니다. 노드의 운영 체제에 따라
콜론(:) 또는 세미콜론(;)으로 다중 경로를 구분해야 합니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_verboseModeClass_description"></a>상세한 클래스 로드</strong>
</dt>
<dd>클래스 로드을 위한 상세한 디버그 출력 사용 여부를 지정합니다. 기본값은 상세한 클래스 로드를 사용하지 않습니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_verboseModeGarbageCollection_description"></a>상세한 가비지 콜렉션</strong>
</dt>
<dd>가비지 콜렉션에 대한 상세한 디버그 출력 사용 여부를 지정합니다. 기본값은 상세한 가비지 콜렉션을 사용하지 않습니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_verboseModeJNI_description"></a>상세한 JNI</strong>
</dt>
<dd>기본 메소드 호출에 대한 상세한 디버그 출력 사용 여부를 지정합니다. 기본값은 상세한 JNI 활동을 사용하지 않습니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_initialHeapSize_description"></a>초기 힙 크기</strong>
</dt>
<dd>JVM 코드에 사용 가능한 초기 힙 크기(MB)를 지정하십시오. 
<p>최소 힙 크기를 늘리면 시작 시간을 줄일 수 있습니다. 가비지 콜렉션 횟수가 줄어들면서 성능이 10% 향상됩니다.</p>

<p>일반적으로, Java 힙 크기가 증가하면 힙이 더 이상 물리적 메모리에
상주하지 않을 때까지 처리량이 향상됩니다.
힙이 디스크에 대한 스와핑을 시작하면 Java 성능이 현저하게 저하됩니다.
</p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">정수</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">OS/400의 경우에는 64, 모든 다른 플랫폼의 경우에는 50</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_maximumHeapSize_description"></a>최대 힙 크기</strong>
</dt>
<dd>JVM 코드에 사용 가능한 최대 힙 크기(MB)를 지정하십시오. 
<p>힙 크기를 늘리면 시작 과정이 개선될 수 있습니다. 가비지 콜렉션 횟수가 줄어들면서 성능이 10% 향상됩니다.</p>

<p>일반적으로, Java 힙 크기가 증가하면 힙이 더 이상 물리적 메모리에
상주하지 않을 때까지 처리량이 향상됩니다.
힙이 디스크에 대한 스와핑을 시작하면 Java 성능이 현저하게 저하됩니다.
따라서 설정한 최대 힙 크기가 적당히 낮아야 실제 메모리 내부에 힙이 들어갈 수 있습니다.</p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">정수</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">OS/400에는 0, 기타 플랫폼에서는 모두 256입니다. 값이 적당히 낮아야 페이징, 혹은 메모리 내용을 디스크로 밀어내는 일을 피할 수 있습니다. </td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_runHProf_description"></a>HProf 실행</strong>
</dt>
<dd>HProf 프로파일러 지원 사용 여부를 지정합니다. 다른 프로파일러를 사용하려면,
 HProf 인수 설정을 사용하는 사용자 정의 프로파일러의 설정을 지정합니다. 기본값은 HProf 프로파일러 지원을 사용하지 않습니다. 
<p>HProf 실행 등록 정보를 true로 설정하려는 경우, HProf 인수 등록 정보에
대해 명령행 프로파일러 인수를 지정해야 합니다. </p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_hprofArguments_description"></a>HProf 인수</strong>
</dt>
<dd>Application Server 프로세스를 시작하는 JVM 가상 시스템으로
전달하기 위한 명령행 프로파일러 인수를 지정합니다. HProf 프로파일러 지원이 사용 가능할 때
인수를 지정할 수 있습니다. 
<p>HProf 인수는 HProf 등록 정보가 true로 설정된 경우에만 필요합니다. </p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_debugMode_description"></a>디버그 모드</strong>
</dt>
<dd>디버그 모드의 JVM 실행 여부를 지정합니다. 기본값은 디버그 모드 지원을 사용하지 않습니다. 
<p>디버그 모드 등록 정보를 true로 설정하면, 디버그 인수 등록 정보에 대한 값으로서 명령행 디버그
인수를 지정해야 합니다. </p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_debugArgs_description"></a>디버그 인수</strong>
</dt>
<dd>Application Server 프로세스를 시작하는 JVM 가상 시스템으로
전달하기 위한 명령행 디버그 인수를 지정합니다. 디버그 모드가 사용 가능할 때 인수를 지정할 수 있습니다. 
<p>디버그 인수는 디버그 모드 등록 정보가 true로 설정된 경우에만 필요합니다. </p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">
단위</td>
<td align="left" valign="top" class="base">Java 명령행 인수</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_genericJvmArguments_description"></a>일반 JVM 인수</strong>
</dt>
<dd>여기서 지정하는 명령행 인수는 Application Server 프로세스를 시작하는 Java 가상 시스템 코드로 전달됩니다.
<p>다음은 <strong>일반 JVM 인수</strong> 필드에 입력할 때 선택적으로 쓸 수 있는 명령행 인수입니다.<ul>

<li>
<strong>-Xquickstart:</strong> 이 값은 기본 모드보다 낮은 최적화 레벨로 초기 컴파일을 할 때 이용할 수 있습니다. 또 나중에는 샘플링 결과에 따라 기본 모드의 초기 컴파일 레벨로 다시 컴파일할 수 있습니다. quickstart는 적당한 초기 속도가 최종 처리량보다 중요한 응용프로그램에서 사용하십시오. 디버그 시나리오, 테스트 준비, 단기 실행 도구에 따라 시작 시간은 15-20% 단축될 수도 있습니다. <strong>-DCOPT_NQREACHDEF </strong>를 더하면 시작 과정이 15% 더 개선됩니다.</li>

<li>
<strong>-Xverify:none:</strong> 이 값을 사용하면 클래스 로드 중 클래스 검증 단계를 건너뛰게 됩니다. JIT(Just In Time) 컴파일러와 함께 <strong>-Xverify:none</strong>을 쓰면 시작 시간이 10-15% 개선됩니다.</li>

<li>
<strong>-Xnoclassgc:</strong> 이 값을 사용하여 클래스 가비지 콜렉션을 사용 불가능으로 할 수 있습니다. 이렇게 하면 클래스 재사용이 더 가능성 있고 약간이나 성능을 개선하게 됩니다. 클래스 가비지 콜렉션은 기본적으로 사용 가능 상태이나 직접 사용 가능하도록 하기를 권장합니다. 출력에는 클래스 가비지 콜렉션 통계가 들어가기 때문에
verbose:gc 구성 설정을 사용하여 가비지 콜렉션 통계를 모니터할 수
있습니다. </li>

<li>
<strong>-Xgcthreads:</strong> 한번에 가비지 콜렉션 스레드를 여러 개 사용할 수 있는데, 이를 <em>병렬 가비지 콜렉션</em>이라고도 합니다. 이 값을 <strong>일반 JVM 인수</strong> 필드에 입력할 때, 시스템에 있는 프로세서 갯수도 입력하십시오(예: <samp>-Xgcthreads=</samp><em>number_of_processors</em>).
시스템에 프로세서가 두 개 이상일 때는 병렬 가비지 콜렉션을 쓰는 게 좋습니다. 이 인수는 IBM Developer
Kit에만 적용됩니다.</li>

<li>
<strong>-Xnocompactgc:</strong> 이 값은 힙 컴팩션이 가장 비싼 가비지
콜렉션 조작이 사용 불가능합니다. IBM Developer Kit에서는 압축을 피하십시오.  힙 압축을 사용 불가능으로 하면 연관된 오버헤드를 모두 제거합니다. 이 값을 <strong>일반 JVM 인수</strong> 필드에 입력할 때 시스템에 있는 프로세서 갯수도 입력하십시오(예: <samp>-Xnocompactgc=</samp><em>number_of_processors</em>).</li>

<li>
<strong>-Xinitsh:</strong> 이 값을 사용하여 클래스 오브젝트를 저장하는 초기 힙 크기를 설정할 수 있습니다. 메소드 정의와 정적 필드도 클래스 오브젝트와 함께 저장됩니다. 시스템 힙 크기에 상한은 없지만 초기 크기를 정확하게 설정하면 시스템 힙 크기를 늘릴 때 비용이 들지 않습니다. 확장할 때는 운영 체제의 메모리 관리자를 호출하기 때문입니다. WebSphere 제품에서 로드하는 클래스 갯수(대략 클래스 8,000개)와 그 평균 크기를알면 초기 시스템 힙 크기를 비교적 정확하게 계산할 수 있습니다. 응용프로그램을 잘 알고 있으면 계산에 포함하는 게 좋습니다. </li>

<li>
<strong>-Xmc:</strong> 스레드 로컬 힙 크기는 힙에서 스레드 전용으로 할당한 부분입니다. 스레드 로컬 힙 크기 때문에 스레드는 오브젝트를 할당할 때 전체 힙을 잠그지 않아도 됩니다.
그러나 스레드 로컬 힙이 가득차면 힙에서 오브젝트 할당을 실행하기 때문에 동기화해야 합니다. 따라서 로컬 캐시 크기를 적절히 설정해야 성능에 미치는 영향을 조절할 수 있으므로 응용프로그램과 그 오브젝트를 잘 알아야 합니다.</li>

<li>
<strong>-Xml:</strong> 이 값을 사용하면 로컬 캐시에서 할당할 오브젝트의 크기 한도를 설정할 수 있습니다. 크기 한도를 넘어서는 오브젝트는 보통 힙에 할당해야 합니다.오브젝트는 최대한 로컬 캐시에서 할당하십시오. 로컬 캐시는 동적으로 늘어나지 않기 때문에 곧 고갈됩니다.
크기가 대단히 커질 오브젝트가 있다면 보통 힙에서 할당하십시오.</li>

</ul>
</p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">
단위</td>
<td align="left" valign="top" class="base">Java 명령행 인수</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_executableJarFileName_description"></a>실행 가능한 JAR 파일 이름</strong>
</dt>
<dd>JVM 가상 시스템이 사용하는 실행 JAR 파일에 대한 전체 경로 이름을 지정합니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">
단위</td>
<td align="left" valign="top" class="base">경로 이름</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_disableJIT_description"></a>JIT 사용 불가능</strong>
</dt>
<dd>JVM 코드에서 JIT(Just In Time) 컴파일러 옵션을 사용 불가능으로 지정합니다. 
<p>JIT 컴파일러를 사용 불가능으로 하면 처리량이 눈에 띄게 줄어듭니다. 그러므로 성능상 이유로 JIT을 사용 가능으로 하십시오.</p>

<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">부울</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">기본값</td>
<td align="left" valign="top" class="base">false (JIT 사용 가능)</td>

</tr>

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">권장</td>
<td align="left" valign="top" class="base">JIT 사용 가능</td>

</tr>

</table>

</dd>
<dt>
<strong><a name="JavaVirtualMachine_osName_description"></a>운영 체제 이름</strong>
</dt>
<dd>주어진 운영 체제에 대한 JVM 설정을 지정합니다. 시작되면, 프로세스는 노드의
운영 체제에 대한 JVM 설정을 사용합니다. 
<table cellpadding="1">

<tr>

<td align="left" valign="top" class="base" style="background-color:#dedede">데이터 유형</td>
<td align="left" valign="top" class="base">문자열</td>

</tr>

</table>

</dd>
</dl>
</div>
<div>
<p>
<strong>관련 정보</strong>
</p>
<a href="rcon_buttons.html">관리 콘솔 단추</a>
<br>

<a href="rcon_pageusage.html">관리 콘솔 페이지 기능</a>
<br>

<a href="urun_rproperty.html">사용자 정의 등록 정보 콜렉션</a>
<br>

</div>
</body>
</html>
